---
id: architecture
title: Security Architecture
sidebar_position: 2
---

# Security Architecture

## Virtual Filesystem {#virtual-filesystem}

Cryptomator provides a virtual drive. Add, edit, remove files as you're used to with just any disk drive.

Files are transparently en- and decrypted.
There are no unencrypted copies on your hard disk drive.
With every access on your files inside the virtual drive, Cryptomator will en- and decrypt these files on-the-fly.

Currently WinFsp (on Windows) and macFUSE (on macOS) and FUSE (Linux) are our frontends of choice.
If they're not available on your system, Cryptomator will fall back on WebDAV, as it is supported on every major operating system.
WebDAV is an HTTP-based protocol and Cryptomator acts as a WebDAV server accepting so-called loopback connections on your local machine only.

Whenever your file manager accesses files through this virtual drive, Cryptomator will process this request via the following layers.

## Vault Configuration {#vault-configuration}

Every vault must have a vault configuration file named `vault.cryptomator` in the root directory of the vault.
It is a JWT containing basic information about the vault and specification what key to use.
The JWT is signed using the 512 bit raw masterkey.

This is an example of an encoded vault configuration file:

```
eyJraWQiOiJtYXN0ZXJrZXlmaWxlOm1hc3RlcmtleS5jcnlwdG9tYXRvciIsInR5cCI6IkpXVCIsImFsZyI6IkhTMjU2In0.eyJmb3JtYXQiOjgsInNob3J0ZW5pbmdUaHJlc2hvbGQiOjIyMCwianRpIjoiY2U5NzZmN2EtN2I5Mi00Y2MwLWI0YzEtYzc0YTZhYTE3Y2Y1IiwiY2lwaGVyQ29tYm8iOiJTSVZfQ1RSTUFDIn0.IJlu4dHb3fqB2fAk9lf8G8zyEXc7OLB-5m9aNxOEXIQ
```

The decoded header:

```js
{
  "kid": "masterkeyfile:masterkey.cryptomator", /* URI of where to get the key */
  "typ": "JWT",
  "alg": "HS256" /* current implementations also support HS384 and HS512 */
}
```

The decoded payload:

```js
{
  "format": 8, /* vault format for checking software compatibility */
  "shorteningThreshold": 220, /* how many characters in ciphertext filenames before shortening */
  "jti": "ce976f7a-7b92-4cc0-b4c1-c74a6aa17cf5", /* random UUID to uniquely identify the vault */
  "cipherCombo": "SIV_GCM" /* mode of operation for the block cipher. Other possible values are "SIV_CTRMAC" */
}
```

When opening a vault, the following steps have to be followed:

1. Decode `vault.cryptomator` without verification.
2. Read `kid` header and, depending on its value, retrieve the masterkey from the specified location.
3. Verify the JWT signature using the concatenation of encryption masterkey and MAC masterkey.
4. Make sure `format` and `cipherCombo` are supported.

## Masterkey {#masterkey}

Each vault has its own 256 bit encryption as well as MAC masterkey used for encryption of file specific keys and file authentication, respectively.

All key material is generated by a CSPRNG (Cryptographically secure pseudorandom number generator).

* In Java (Desktop, Android App), we use [SecureRandom](https://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html) with SHA1PRNG, seeded with 440 bits from `SecureRandom.getInstanceStrong()`.
* In Javascript (Cryptomator Hub), we rely on [crypto.subtle.generateKey()](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey).
* In Swift (iOS App), we use [SecRandomCopyBytes](https://developer.apple.com/documentation/security/1399291-secrandomcopybytes) with `kSecRandomDefault`.

These keys are themselves protected and can be retrieved using, either of the following methods, depending on the use case:

### Using Cryptomator Hub {#using-cryptomator-hub}

When using [Cryptomator Hub](/docs/hub/access-vault.md), the encrypted raw masterkey can be retrieved from a the server component.

:::note
If a vault is managed by Cryptomator Hub, the `vault.cryptomator`'s `kid` field will point to the resource URI of said vault on the corresponding Hub instance, prefixed by `hub+`.

Example: `"kid": "hub+https://hub.example.com/api/vaults/bb36d67c"`
:::

Every Cryptomator Hub user who is authorized to access this vault will retrieve an individual ciphertext from the vault's `/access-token` sub-resource.
This ciphertext is formatted as a [JWE](https://tools.ietf.org/html/rfc7516) and can be decrypted using [ECDH-ES](https://datatracker.ietf.org/doc/html/rfc7518#section-4.6) and the user's static private key.
The JWE's decoded header looks something like this:

```js
{
    "alg": "ECDH-ES",
    "enc": "A256GCM",
    "epk": {
        "crv": "P-384",
        "kty": "EC",
        "x": "p1J...g",
        "y": "8Il...H"
    }
    "apu": "",
    "apv": ""
}
```

The JWE's decrypted payload holds a single value, which can then be consumed by Cryptomator to unlock the vault:

```js
{
    "key": "H7u...o==" /* 512 bit raw masterkey */
}
```

### Masterkey File {#masterkey-file}

Alternatively, for normal password-protected vaults, Cryptomator will derive a 32byte long KEK (Key-encryption key) via [scrypt](https://tools.ietf.org/html/rfc7914) (non-parallel), encrypt both masterkeys using [AES Key Wrap (RFC 3394)](https://tools.ietf.org/html/rfc3394), and store the results together with the key derivation parameters in a JSON file:

```
encryptionMasterKey := createRandomBytes(32)
macMasterKey := createRandomBytes(32)
kek := scrypt(password, scryptSalt, scryptCostParam, scryptBlockSize)
wrappedEncryptionMasterKey := aesKeyWrap(encryptionMasterKey, kek)
wrappedMacMasterKey := aesKeyWrap(macMasterKey, kek)
```

<WhiteBox>
  <Image src="/img/security/key-derivation.png" srcset="/img/security/key-derivation.png 1x, /img/security/key-derivation@2x.png 2x" alt="KEK Derivation" width="336" height="71" />
</WhiteBox>

The wrapped keys and the parameters needed to derive the KEK are then stored as integers or Base64-encoded strings in a JSON file named `masterkey.cryptomator`, which is located in the root directory of the vault.

```js
{
    "version": 999, /* deprecated, vault format is now specified in the vault configuration */
    "scryptSalt": "QGk...jY=",
    "scryptCostParam": 32768,
    "scryptBlockSize": 8,
    "primaryMasterKey": "QDi...Q==", /* wrappedEncryptionMasterKey */
    "hmacMasterKey": "L83...Q==", /* wrappedMacMasterKey */
    "versionMac": "3/U...9Q=" /* HMAC-256 of vault version to prevent undetected downgrade attacks */
}
```

When unlocking a vault the KEK is used to unwrap (i.e. decrypt) the stored masterkeys.

<WhiteBox>
  <Image src="/img/security/masterkey-decryption.png" srcset="/img/security/masterkey-decryption.png 1x, /img/security/masterkey-decryption@2x.png 2x" alt="Masterkey Decryption" width="439" height="200" />
</WhiteBox>

### Key Rotation: Multiple Masterkey Generations using Cryptomator Hub with Universal Vault Format {#key-rotation}

[Unified Vault Format (UVF)](https://github.com/encryption-alliance/unified-vault-format) defines a common vendor-independent standard inspired by and partially based on [Vault Format 8](/docs/misc/vault-format-history.md#format-8).

Access to a vault starts by reading its general metadata, which is stored in the `vault.uvf` file (and as such serves a similar purpose as `vault.cryptomator` in Vault Format 8).
The primary copy of this file is stored within Cryptomator Hub. For redundancy and interoperability purposes, further copies of this file are created within the vault itself during unlock.
It can contain many key generations - only the latest generation is used for data encryption.
The older generations are used to read the older data encrypted with previous generation keys.
See [Key Rotation](uvf.md#key-rotation) for more details.

Cryptomator Hub [1.3.0](https://github.com/cryptomator/hub/releases/tag/1.3.0) introduced user-specific vault access token JWE containing the vault masterkey for data encryption.
In the UVF setting, the UVF metadata must hold the current and older (master)key generations.

In order to give access to the vault metadata, the vault access token will contain a Vault Member key, which allows to decrypt the `vault.uvf` metadata.
Specifically, a Vault Owner will have an access token under `/access-token` sub-resource of the form

```json
{
    "key": "{member key}",
    "recoveryKey": "{recovery key}"
}
```

Non-owner Vault Members will not have the `recoveryKey` shared with them, the JWE will only contain the `key` element.
Vault members can decrypt their access token using their private user key.
See [User Key Pair](hub.md#user-key-pair).

Upon vault creation, a new member key and an asymmetric recovery key pair are generated. The public recovery key and the `vault.uvf` JWE are uploaded to Cryptomator Hub.

<WhiteBox>
  <Image src="/img/security/uvf-vault-creation.drawio.png" alt="UVF Vault Creation" width="700" />
</WhiteBox>

See [Key Rotation](uvf.md#key-rotation) for more details on key rotation and `vault.uvf`.

Vault sharing is the same as with access tokens introduced in Cryptomator Hub [1.3.0](https://github.com/cryptomator/hub/releases/tag/1.3.0).

Only the payload's `key` field contains the latest member key (instead of the masterkey) and the `recoveryKey` (Vault Owners only).

<WhiteBox>
  <Image src="/img/security/uvf-vault-sharing.drawio.png" alt="UVF Vault Sharing" width="550" />
</WhiteBox>
